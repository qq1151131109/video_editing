/**
 * 智能视频裁切扩展 - 简化稳定版
 */

import { app } from "../../scripts/app.js";

console.log("🎬 智能视频裁切扩展开始加载...");

// 宽高比预设
const ASPECT_RATIOS = {
    "16:9": [16, 9],
    "9:16": [9, 16],
    "1:1": [1, 1],
    "4:3": [4, 3],
    "3:4": [3, 4]
};

// 创建简单的比例选择按钮
function createRatioButtons(node) {
    return {
        name: "ratio_selector",
        type: "custom_buttons",
        value: "",

        draw: function(ctx, node, widgetWidth, y, widgetHeight) {
            const margin = 10;
            const buttonHeight = 25;
            const ratios = Object.keys(ASPECT_RATIOS);
            const buttonWidth = (widgetWidth - margin * 2) / ratios.length - 3;

            ctx.font = "12px Arial";
            ctx.textAlign = "center";

            ratios.forEach((ratio, i) => {
                const x = margin + i * (buttonWidth + 3);

                // 获取当前选择的比例
                const currentRatio = node.widgets.find(w => w.name === "aspect_ratio")?.value || "";
                const isActive = currentRatio === ratio;

                // 绘制按钮
                ctx.fillStyle = isActive ? "#667eea" : "#404040";
                ctx.fillRect(x, y, buttonWidth, buttonHeight);

                ctx.strokeStyle = isActive ? "#8a9eff" : "#666";
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, buttonWidth, buttonHeight);

                // 绘制文本
                ctx.fillStyle = "#ffffff";
                ctx.fillText(ratio, x + buttonWidth/2, y + buttonHeight/2 + 4);
            });

            return buttonHeight + 10;
        },

        mouse: function(event, pos, node) {
            if (event.type === "pointerdown") {
                const margin = 10;
                const ratios = Object.keys(ASPECT_RATIOS);
                const buttonWidth = (node.size[0] - margin * 2) / ratios.length - 3;

                for (let i = 0; i < ratios.length; i++) {
                    const x = margin + i * (buttonWidth + 3);
                    if (pos[0] >= x && pos[0] <= x + buttonWidth) {
                        this.applyRatio(ratios[i], node);
                        return true;
                    }
                }
            }
            return false;
        },

        getParam: function(node, name) {
            const widget = node.widgets.find(w => w.name === name);
            return widget ? widget.value : null;
        },

        applyRatio: function(ratio, node) {
            if (!ASPECT_RATIOS[ratio]) return;

            const [w, h] = ASPECT_RATIOS[ratio];
            const targetAspect = w / h;

            // 从节点参数获取真实视频分辨率
            const videoWidth = this.getParam(node, "video_width") || 1920;
            const videoHeight = this.getParam(node, "video_height") || 1080;

            let cropWidth, cropHeight;

            if (videoWidth / videoHeight > targetAspect) {
                cropHeight = videoHeight;
                cropWidth = Math.round(cropHeight * targetAspect);
            } else {
                cropWidth = videoWidth;
                cropHeight = Math.round(cropWidth / targetAspect);
            }

            const cropX = Math.round((videoWidth - cropWidth) / 2);
            const cropY = Math.round((videoHeight - cropHeight) / 2);

            // 更新节点参数
            const updates = {
                crop_x1: cropX,
                crop_y1: cropY,
                crop_x2: cropX + cropWidth,
                crop_y2: cropY + cropHeight,
                aspect_ratio: ratio,
                crop_mode: "智能居中"
            };

            Object.entries(updates).forEach(([name, value]) => {
                const widget = node.widgets.find(w => w.name === name);
                if (widget) {
                    widget.value = value;
                    if (node.onWidgetChanged) {
                        node.onWidgetChanged(name, value);
                    }
                }
            });

            console.log(`📐 应用比例: ${ratio}, 裁切区域: ${cropX},${cropY} -> ${cropX + cropWidth},${cropY + cropHeight}`);
        },

        computeSize: function(width) {
            return [width, 40];
        }
    };
}

// 创建简单的预览界面
function createCropPreview(node) {
    return {
        name: "crop_preview",
        type: "custom_preview",
        value: "",

        draw: function(ctx, node, widgetWidth, y, widgetHeight) {
            const margin = 10;
            const previewHeight = 180;
            const canvasWidth = widgetWidth - margin * 2;

            // 绘制背景
            ctx.fillStyle = "#1a1a1a";
            ctx.fillRect(margin, y, canvasWidth, previewHeight);

            ctx.strokeStyle = "#555";
            ctx.lineWidth = 1;
            ctx.strokeRect(margin, y, canvasWidth, previewHeight);

            // 获取当前裁切参数
            const x1 = this.getParam(node, "crop_x1") || 480;
            const y1 = this.getParam(node, "crop_y1") || 270;
            const x2 = this.getParam(node, "crop_x2") || 1440;
            const y2 = this.getParam(node, "crop_y2") || 810;

            // 从节点参数获取真实视频分辨率
            const videoWidth = this.getParam(node, "video_width") || 1920;
            const videoHeight = this.getParam(node, "video_height") || 1080;
            const scale = Math.min(canvasWidth / videoWidth, previewHeight / videoHeight);

            const scaledVideoWidth = videoWidth * scale;
            const scaledVideoHeight = videoHeight * scale;
            const offsetX = margin + (canvasWidth - scaledVideoWidth) / 2;
            const offsetY = y + (previewHeight - scaledVideoHeight) / 2;

            // 尝试绘制真实视频帧
            const previewFrame = this.getParam(node, "preview_frame");
            console.log("预览帧路径:", previewFrame);

            if (previewFrame && previewFrame.trim() && this.loadVideoFrame) {
                this.loadVideoFrame(ctx, previewFrame, offsetX, offsetY, scaledVideoWidth, scaledVideoHeight);
            } else {
                // 回退到渐变背景
                console.log("使用默认背景，预览帧:", previewFrame);
                const gradient = ctx.createLinearGradient(offsetX, offsetY, offsetX + scaledVideoWidth, offsetY + scaledVideoHeight);
                gradient.addColorStop(0, '#4a5568');
                gradient.addColorStop(0.5, '#2d3748');
                gradient.addColorStop(1, '#1a202c');
                ctx.fillStyle = gradient;
                ctx.fillRect(offsetX, offsetY, scaledVideoWidth, scaledVideoHeight);
            }

            // 绘制遮罩
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(offsetX, offsetY, scaledVideoWidth, scaledVideoHeight);

            // 计算并绘制裁切框
            const cropX = offsetX + x1 * scale;
            const cropY = offsetY + y1 * scale;
            const cropWidth = (x2 - x1) * scale;
            const cropHeight = (y2 - y1) * scale;

            // 清除裁切区域遮罩
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillRect(cropX, cropY, cropWidth, cropHeight);
            ctx.globalCompositeOperation = 'source-over';

            // 绘制裁切框
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 2;
            ctx.strokeRect(cropX, cropY, cropWidth, cropHeight);

            // 绘制调整手柄
            const handleSize = 10;
            const halfHandle = handleSize / 2;

            // 手柄样式
            ctx.fillStyle = '#ff4444';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;

            // 8个手柄位置：4个角 + 4个边中点
            const handles = [
                // 四个角
                { x: x1, y: y1, type: 'corner' }, // 左上
                { x: x2, y: y1, type: 'corner' }, // 右上
                { x: x1, y: y2, type: 'corner' }, // 左下
                { x: x2, y: y2, type: 'corner' }, // 右下

                // 四个边中点
                { x: x1, y: y1 + (y2-y1)/2, type: 'edge' }, // 左边
                { x: x2, y: y1 + (y2-y1)/2, type: 'edge' }, // 右边
                { x: x1 + (x2-x1)/2, y: y1, type: 'edge' }, // 上边
                { x: x1 + (x2-x1)/2, y: y2, type: 'edge' } // 下边
            ];

            handles.forEach(handle => {
                const hx = offsetX + handle.x * scale - halfHandle;
                const hy = offsetY + handle.y * scale - halfHandle;

                if (handle.type === 'corner') {
                    // 角落手柄 - 方形
                    ctx.fillRect(hx, hy, handleSize, handleSize);
                    ctx.strokeRect(hx, hy, handleSize, handleSize);
                } else {
                    // 边中点手柄 - 圆形
                    ctx.beginPath();
                    ctx.arc(hx + halfHandle, hy + halfHandle, halfHandle, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
            });

            // 绘制信息
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Arial';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1.5;

            const info = `视频: ${videoWidth}×${videoHeight} | 裁切: ${x2-x1}×${y2-y1} | 位置: (${x1}, ${y1})`;
            const textY = y + previewHeight - 8;

            ctx.strokeText(info, margin + 5, textY);
            ctx.fillText(info, margin + 5, textY);

            // 保存信息用于鼠标事件
            this.canvasInfo = {
                offsetX, offsetY, scale, margin, y,
                canvasWidth, canvasHeight: previewHeight,
                videoWidth, videoHeight
            };

            return previewHeight + 15;
        },

        getParam: function(node, name) {
            const widget = node.widgets.find(w => w.name === name);
            return widget ? widget.value : null;
        },

        loadVideoFrame: function(ctx, framePath, x, y, width, height) {
            console.log("尝试加载视频帧:", framePath);

            // 如果已经加载过这个图片，直接绘制
            if (this.loadedImage && this.loadedImagePath === framePath) {
                console.log("使用缓存的图片");
                ctx.drawImage(this.loadedImage, x, y, width, height);
                return;
            }

            // 立即绘制默认背景，避免空白
            const gradient = ctx.createLinearGradient(x, y, x + width, y + height);
            gradient.addColorStop(0, '#4a5568');
            gradient.addColorStop(0.5, '#2d3748');
            gradient.addColorStop(1, '#1a202c');
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, width, height);

            // 加载新的图片
            const img = new Image();
            img.onload = () => {
                console.log("✅ 视频帧加载成功:", framePath);
                this.loadedImage = img;
                this.loadedImagePath = framePath;
                ctx.drawImage(img, x, y, width, height);
                // 触发重绘
                if (app && app.canvas) {
                    app.canvas.setDirty(true);
                }
            };
            img.onerror = (e) => {
                console.log("❌ 无法加载视频预览帧:", framePath, e);
                // 保持默认背景
            };

            // 设置图片源
            let imgSrc = framePath;

            console.log("图片源URL:", imgSrc);
            img.src = imgSrc;
        },

        setParam: function(node, name, value) {
            const widget = node.widgets.find(w => w.name === name);
            if (widget) {
                widget.value = value;
                if (node.onWidgetChanged) {
                    node.onWidgetChanged(name, value);
                }
            }
        },

        detectResizeHandle: function(mouseX, mouseY, cropX, cropY, cropWidth, cropHeight) {
            const tolerance = 15; // 增大检测容差

            // 检测四个角（优先检测角落）
            if (this.isNearPoint(mouseX, mouseY, cropX, cropY, tolerance)) {
                console.log("检测到左上角");
                return 'nw';
            }
            if (this.isNearPoint(mouseX, mouseY, cropX + cropWidth, cropY, tolerance)) {
                console.log("检测到右上角");
                return 'ne';
            }
            if (this.isNearPoint(mouseX, mouseY, cropX, cropY + cropHeight, tolerance)) {
                console.log("检测到左下角");
                return 'sw';
            }
            if (this.isNearPoint(mouseX, mouseY, cropX + cropWidth, cropY + cropHeight, tolerance)) {
                console.log("检测到右下角");
                return 'se';
            }

            // 检测四个边
            if (Math.abs(mouseX - cropX) < tolerance && mouseY >= cropY && mouseY <= cropY + cropHeight) {
                console.log("检测到左边");
                return 'w';
            }
            if (Math.abs(mouseX - (cropX + cropWidth)) < tolerance && mouseY >= cropY && mouseY <= cropY + cropHeight) {
                console.log("检测到右边");
                return 'e';
            }
            if (Math.abs(mouseY - cropY) < tolerance && mouseX >= cropX && mouseX <= cropX + cropWidth) {
                console.log("检测到上边");
                return 'n';
            }
            if (Math.abs(mouseY - (cropY + cropHeight)) < tolerance && mouseX >= cropX && mouseX <= cropX + cropWidth) {
                console.log("检测到下边");
                return 's';
            }

            // 检测内部区域（移动）
            if (mouseX >= cropX + tolerance && mouseX <= cropX + cropWidth - tolerance &&
                mouseY >= cropY + tolerance && mouseY <= cropY + cropHeight - tolerance) {
                return 'move';
            }

            return null;
        },

        isNearPoint: function(x1, y1, x2, y2, tolerance) {
            return Math.abs(x1 - x2) < tolerance && Math.abs(y1 - y2) < tolerance;
        },

        mouse: function(event, pos, node) {
            if (!this.canvasInfo) return false;

            const { offsetX, offsetY, scale, margin, y, canvasWidth, canvasHeight, videoWidth, videoHeight } = this.canvasInfo;

            // 检查是否在预览区域内
            if (pos[0] < margin || pos[0] > margin + canvasWidth ||
                pos[1] < y || pos[1] > y + canvasHeight) {
                // 鼠标离开区域时重置光标
                if (event.type === "pointermove" && !this.isDragging) {
                    this.setCursor(null);
                }
                return false;
            }

            // 转换坐标到视频坐标系
            const videoX = (pos[0] - offsetX) / scale;
            const videoY = (pos[1] - offsetY) / scale;

            // 限制在视频区域内
            if (videoX < 0 || videoX > videoWidth || videoY < 0 || videoY > videoHeight) {
                // 鼠标离开视频区域时重置光标
                if (event.type === "pointermove" && !this.isDragging) {
                    this.setCursor(null);
                }
                return false;
            }

            // 获取当前裁切参数
            const x1 = this.getParam(node, "crop_x1") || 480;
            const y1 = this.getParam(node, "crop_y1") || 270;
            const x2 = this.getParam(node, "crop_x2") || 1440;
            const y2 = this.getParam(node, "crop_y2") || 810;

            // 计算裁切框在画布上的位置
            const cropX = x1;
            const cropY = y1;
            const cropWidth = x2 - x1;
            const cropHeight = y2 - y1;

            if (event.type === "pointermove" && !this.isDragging) {
                // 检测鼠标悬停位置，设置光标
                const handle = this.detectResizeHandle(videoX, videoY, cropX, cropY, cropWidth, cropHeight);
                this.setCursor(handle);
                return false;
            }

            if (event.type === "pointerdown") {
                this.isDragging = true;
                this.dragStartX = videoX;
                this.dragStartY = videoY;

                // 检测拖拽类型
                this.resizeHandle = this.detectResizeHandle(videoX, videoY, cropX, cropY, cropWidth, cropHeight);
                console.log("拖拽开始:", this.resizeHandle, "坐标:", videoX, videoY, "裁切框:", cropX, cropY, cropWidth, cropHeight);

                // 记录当前裁切参数
                this.startCropX1 = x1;
                this.startCropY1 = y1;
                this.startCropX2 = x2;
                this.startCropY2 = y2;

                return true;
            } else if (event.type === "pointermove" && this.isDragging) {
                const deltaX = videoX - this.dragStartX;
                const deltaY = videoY - this.dragStartY;

                let newX1 = this.startCropX1;
                let newY1 = this.startCropY1;
                let newX2 = this.startCropX2;
                let newY2 = this.startCropY2;

                // 根据拖拽类型调整裁切框
                switch (this.resizeHandle) {
                    case 'move':
                        // 移动整个框
                        const currentWidth = newX2 - newX1;
                        const currentHeight = newY2 - newY1;
                        newX1 = this.startCropX1 + deltaX;
                        newY1 = this.startCropY1 + deltaY;
                        newX2 = newX1 + currentWidth;
                        newY2 = newY1 + currentHeight;
                        break;

                    case 'nw': // 左上角
                        newX1 = this.startCropX1 + deltaX;
                        newY1 = this.startCropY1 + deltaY;
                        break;

                    case 'ne': // 右上角
                        newX2 = this.startCropX2 + deltaX;
                        newY1 = this.startCropY1 + deltaY;
                        break;

                    case 'sw': // 左下角
                        newX1 = this.startCropX1 + deltaX;
                        newY2 = this.startCropY2 + deltaY;
                        break;

                    case 'se': // 右下角
                        newX2 = this.startCropX2 + deltaX;
                        newY2 = this.startCropY2 + deltaY;
                        break;

                    case 'w': // 左边
                        newX1 = this.startCropX1 + deltaX;
                        break;

                    case 'e': // 右边
                        newX2 = this.startCropX2 + deltaX;
                        break;

                    case 'n': // 上边
                        newY1 = this.startCropY1 + deltaY;
                        break;

                    case 's': // 下边
                        newY2 = this.startCropY2 + deltaY;
                        break;
                }

                // 智能边界约束和最小尺寸处理
                const minSize = 50;

                // 对于移动操作，保持尺寸不变
                if (this.resizeHandle === 'move') {
                    const currentWidth = newX2 - newX1;
                    const currentHeight = newY2 - newY1;

                    // 边界约束
                    newX1 = Math.max(0, Math.min(newX1, videoWidth - currentWidth));
                    newY1 = Math.max(0, Math.min(newY1, videoHeight - currentHeight));
                    newX2 = newX1 + currentWidth;
                    newY2 = newY1 + currentHeight;
                } else {
                    // 对于调整大小操作，分别处理每个方向

                    // 先应用基本边界约束
                    newX1 = Math.max(0, Math.min(newX1, videoWidth));
                    newY1 = Math.max(0, Math.min(newY1, videoHeight));
                    newX2 = Math.max(0, Math.min(newX2, videoWidth));
                    newY2 = Math.max(0, Math.min(newY2, videoHeight));

                    // 确保坐标顺序正确
                    if (newX1 > newX2) [newX1, newX2] = [newX2, newX1];
                    if (newY1 > newY2) [newY1, newY2] = [newY2, newY1];

                    // 确保最小尺寸
                    if (newX2 - newX1 < minSize) {
                        const centerX = (newX1 + newX2) / 2;
                        newX1 = Math.max(0, centerX - minSize/2);
                        newX2 = Math.min(videoWidth, newX1 + minSize);
                        if (newX2 - newX1 < minSize) {
                            newX1 = Math.max(0, newX2 - minSize);
                        }
                    }

                    if (newY2 - newY1 < minSize) {
                        const centerY = (newY1 + newY2) / 2;
                        newY1 = Math.max(0, centerY - minSize/2);
                        newY2 = Math.min(videoHeight, newY1 + minSize);
                        if (newY2 - newY1 < minSize) {
                            newY1 = Math.max(0, newY2 - minSize);
                        }
                    }
                }

                // 更新参数
                this.setParam(node, "crop_x1", Math.round(newX1));
                this.setParam(node, "crop_y1", Math.round(newY1));
                this.setParam(node, "crop_x2", Math.round(newX2));
                this.setParam(node, "crop_y2", Math.round(newY2));
                this.setParam(node, "crop_mode", "自定义坐标");

                return true;
            } else if (event.type === "pointerup") {
                this.isDragging = false;
                this.resizeHandle = null;
                return true;
            }

            return false;
        },

        setCursor: function(handle) {
            if (!document.body) return;

            const cursors = {
                'nw': 'nw-resize',
                'ne': 'ne-resize',
                'sw': 'sw-resize',
                'se': 'se-resize',
                'w': 'w-resize',
                'e': 'e-resize',
                'n': 'n-resize',
                's': 's-resize',
                'move': 'move',
                null: 'default'
            };

            document.body.style.cursor = cursors[handle] || 'default';
        },

        computeSize: function(width) {
            return [width, 200];
        }
    };
}

// 注册扩展
app.registerExtension({
    name: "VideoEditing.SmartCrop",

    async beforeRegisterNodeDef(nodeType, nodeData, app) {
        if (nodeData.name === "EnhancedVideoCropNode") {
            console.log("🎯 注册智能视频裁切节点扩展");

            const onNodeCreated = nodeType.prototype.onNodeCreated;
            nodeType.prototype.onNodeCreated = function() {
                const result = onNodeCreated?.apply(this, arguments);

                console.log("📋 创建智能视频裁切节点，添加交互界面...");

                // 添加比例选择按钮
                const ratioWidget = createRatioButtons(this);
                this.addCustomWidget(ratioWidget);

                // 添加交互式预览
                const previewWidget = createCropPreview(this);
                this.addCustomWidget(previewWidget);

                console.log("✅ 交互界面已添加到节点");

                return result;
            };
        }
    }
});

console.log("🎬 智能视频裁切扩展已加载");