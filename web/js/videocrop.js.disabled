/**
 * æ™ºèƒ½è§†é¢‘è£åˆ‡æ‰©å±• - ç®€åŒ–ç¨³å®šç‰ˆ
 */

import { app } from "../../scripts/app.js";

console.log("ğŸ¬ æ™ºèƒ½è§†é¢‘è£åˆ‡æ‰©å±•å¼€å§‹åŠ è½½...");

// å®½é«˜æ¯”é¢„è®¾
const ASPECT_RATIOS = {
    "16:9": [16, 9],
    "9:16": [9, 16],
    "1:1": [1, 1],
    "4:3": [4, 3],
    "3:4": [3, 4]
};

// åˆ›å»ºç®€å•çš„æ¯”ä¾‹é€‰æ‹©æŒ‰é’®
function createRatioButtons(node) {
    return {
        name: "ratio_selector",
        type: "custom_buttons",
        value: "",

        draw: function(ctx, node, widgetWidth, y, widgetHeight) {
            const margin = 10;
            const buttonHeight = 25;
            const ratios = Object.keys(ASPECT_RATIOS);
            const buttonWidth = (widgetWidth - margin * 2) / ratios.length - 3;

            ctx.font = "12px Arial";
            ctx.textAlign = "center";

            ratios.forEach((ratio, i) => {
                const x = margin + i * (buttonWidth + 3);

                // è·å–å½“å‰é€‰æ‹©çš„æ¯”ä¾‹
                const currentRatio = node.widgets.find(w => w.name === "aspect_ratio")?.value || "";
                const isActive = currentRatio === ratio;

                // ç»˜åˆ¶æŒ‰é’®
                ctx.fillStyle = isActive ? "#667eea" : "#404040";
                ctx.fillRect(x, y, buttonWidth, buttonHeight);

                ctx.strokeStyle = isActive ? "#8a9eff" : "#666";
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, buttonWidth, buttonHeight);

                // ç»˜åˆ¶æ–‡æœ¬
                ctx.fillStyle = "#ffffff";
                ctx.fillText(ratio, x + buttonWidth/2, y + buttonHeight/2 + 4);
            });

            return buttonHeight + 10;
        },

        mouse: function(event, pos, node) {
            if (event.type === "pointerdown") {
                const margin = 10;
                const ratios = Object.keys(ASPECT_RATIOS);
                const buttonWidth = (node.size[0] - margin * 2) / ratios.length - 3;

                for (let i = 0; i < ratios.length; i++) {
                    const x = margin + i * (buttonWidth + 3);
                    if (pos[0] >= x && pos[0] <= x + buttonWidth) {
                        this.applyRatio(ratios[i], node);
                        return true;
                    }
                }
            }
            return false;
        },

        getParam: function(node, name) {
            const widget = node.widgets.find(w => w.name === name);
            return widget ? widget.value : null;
        },

        applyRatio: function(ratio, node) {
            if (!ASPECT_RATIOS[ratio]) return;

            const [w, h] = ASPECT_RATIOS[ratio];
            const targetAspect = w / h;

            // ä»èŠ‚ç‚¹å‚æ•°è·å–çœŸå®è§†é¢‘åˆ†è¾¨ç‡
            const videoWidth = this.getParam(node, "video_width") || 1920;
            const videoHeight = this.getParam(node, "video_height") || 1080;

            let cropWidth, cropHeight;

            if (videoWidth / videoHeight > targetAspect) {
                cropHeight = videoHeight;
                cropWidth = Math.round(cropHeight * targetAspect);
            } else {
                cropWidth = videoWidth;
                cropHeight = Math.round(cropWidth / targetAspect);
            }

            const cropX = Math.round((videoWidth - cropWidth) / 2);
            const cropY = Math.round((videoHeight - cropHeight) / 2);

            // æ›´æ–°èŠ‚ç‚¹å‚æ•°
            const updates = {
                crop_x1: cropX,
                crop_y1: cropY,
                crop_x2: cropX + cropWidth,
                crop_y2: cropY + cropHeight,
                aspect_ratio: ratio,
                crop_mode: "æ™ºèƒ½å±…ä¸­"
            };

            Object.entries(updates).forEach(([name, value]) => {
                const widget = node.widgets.find(w => w.name === name);
                if (widget) {
                    widget.value = value;
                    if (node.onWidgetChanged) {
                        node.onWidgetChanged(name, value);
                    }
                }
            });

            console.log(`ğŸ“ åº”ç”¨æ¯”ä¾‹: ${ratio}, è£åˆ‡åŒºåŸŸ: ${cropX},${cropY} -> ${cropX + cropWidth},${cropY + cropHeight}`);
        },

        computeSize: function(width) {
            return [width, 40];
        }
    };
}

// åˆ›å»ºç®€å•çš„é¢„è§ˆç•Œé¢
function createCropPreview(node) {
    return {
        name: "crop_preview",
        type: "custom_preview",
        value: "",

        draw: function(ctx, node, widgetWidth, y, widgetHeight) {
            const margin = 10;
            const previewHeight = 180;
            const canvasWidth = widgetWidth - margin * 2;

            // ç»˜åˆ¶èƒŒæ™¯
            ctx.fillStyle = "#1a1a1a";
            ctx.fillRect(margin, y, canvasWidth, previewHeight);

            ctx.strokeStyle = "#555";
            ctx.lineWidth = 1;
            ctx.strokeRect(margin, y, canvasWidth, previewHeight);

            // è·å–å½“å‰è£åˆ‡å‚æ•°
            const x1 = this.getParam(node, "crop_x1") || 480;
            const y1 = this.getParam(node, "crop_y1") || 270;
            const x2 = this.getParam(node, "crop_x2") || 1440;
            const y2 = this.getParam(node, "crop_y2") || 810;

            // ä»èŠ‚ç‚¹å‚æ•°è·å–çœŸå®è§†é¢‘åˆ†è¾¨ç‡
            const videoWidth = this.getParam(node, "video_width") || 1920;
            const videoHeight = this.getParam(node, "video_height") || 1080;
            const scale = Math.min(canvasWidth / videoWidth, previewHeight / videoHeight);

            const scaledVideoWidth = videoWidth * scale;
            const scaledVideoHeight = videoHeight * scale;
            const offsetX = margin + (canvasWidth - scaledVideoWidth) / 2;
            const offsetY = y + (previewHeight - scaledVideoHeight) / 2;

            // å°è¯•ç»˜åˆ¶çœŸå®è§†é¢‘å¸§
            const previewFrame = this.getParam(node, "preview_frame");
            console.log("é¢„è§ˆå¸§è·¯å¾„:", previewFrame);

            if (previewFrame && previewFrame.trim() && this.loadVideoFrame) {
                this.loadVideoFrame(ctx, previewFrame, offsetX, offsetY, scaledVideoWidth, scaledVideoHeight);
            } else {
                // å›é€€åˆ°æ¸å˜èƒŒæ™¯
                console.log("ä½¿ç”¨é»˜è®¤èƒŒæ™¯ï¼Œé¢„è§ˆå¸§:", previewFrame);
                const gradient = ctx.createLinearGradient(offsetX, offsetY, offsetX + scaledVideoWidth, offsetY + scaledVideoHeight);
                gradient.addColorStop(0, '#4a5568');
                gradient.addColorStop(0.5, '#2d3748');
                gradient.addColorStop(1, '#1a202c');
                ctx.fillStyle = gradient;
                ctx.fillRect(offsetX, offsetY, scaledVideoWidth, scaledVideoHeight);
            }

            // ç»˜åˆ¶é®ç½©
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(offsetX, offsetY, scaledVideoWidth, scaledVideoHeight);

            // è®¡ç®—å¹¶ç»˜åˆ¶è£åˆ‡æ¡†
            const cropX = offsetX + x1 * scale;
            const cropY = offsetY + y1 * scale;
            const cropWidth = (x2 - x1) * scale;
            const cropHeight = (y2 - y1) * scale;

            // æ¸…é™¤è£åˆ‡åŒºåŸŸé®ç½©
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillRect(cropX, cropY, cropWidth, cropHeight);
            ctx.globalCompositeOperation = 'source-over';

            // ç»˜åˆ¶è£åˆ‡æ¡†
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 2;
            ctx.strokeRect(cropX, cropY, cropWidth, cropHeight);

            // ç»˜åˆ¶è°ƒæ•´æ‰‹æŸ„
            const handleSize = 10;
            const halfHandle = handleSize / 2;

            // æ‰‹æŸ„æ ·å¼
            ctx.fillStyle = '#ff4444';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;

            // 8ä¸ªæ‰‹æŸ„ä½ç½®ï¼š4ä¸ªè§’ + 4ä¸ªè¾¹ä¸­ç‚¹
            const handles = [
                // å››ä¸ªè§’
                { x: x1, y: y1, type: 'corner' }, // å·¦ä¸Š
                { x: x2, y: y1, type: 'corner' }, // å³ä¸Š
                { x: x1, y: y2, type: 'corner' }, // å·¦ä¸‹
                { x: x2, y: y2, type: 'corner' }, // å³ä¸‹

                // å››ä¸ªè¾¹ä¸­ç‚¹
                { x: x1, y: y1 + (y2-y1)/2, type: 'edge' }, // å·¦è¾¹
                { x: x2, y: y1 + (y2-y1)/2, type: 'edge' }, // å³è¾¹
                { x: x1 + (x2-x1)/2, y: y1, type: 'edge' }, // ä¸Šè¾¹
                { x: x1 + (x2-x1)/2, y: y2, type: 'edge' } // ä¸‹è¾¹
            ];

            handles.forEach(handle => {
                const hx = offsetX + handle.x * scale - halfHandle;
                const hy = offsetY + handle.y * scale - halfHandle;

                if (handle.type === 'corner') {
                    // è§’è½æ‰‹æŸ„ - æ–¹å½¢
                    ctx.fillRect(hx, hy, handleSize, handleSize);
                    ctx.strokeRect(hx, hy, handleSize, handleSize);
                } else {
                    // è¾¹ä¸­ç‚¹æ‰‹æŸ„ - åœ†å½¢
                    ctx.beginPath();
                    ctx.arc(hx + halfHandle, hy + halfHandle, halfHandle, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
            });

            // ç»˜åˆ¶ä¿¡æ¯
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Arial';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1.5;

            const info = `è§†é¢‘: ${videoWidth}Ã—${videoHeight} | è£åˆ‡: ${x2-x1}Ã—${y2-y1} | ä½ç½®: (${x1}, ${y1})`;
            const textY = y + previewHeight - 8;

            ctx.strokeText(info, margin + 5, textY);
            ctx.fillText(info, margin + 5, textY);

            // ä¿å­˜ä¿¡æ¯ç”¨äºé¼ æ ‡äº‹ä»¶
            this.canvasInfo = {
                offsetX, offsetY, scale, margin, y,
                canvasWidth, canvasHeight: previewHeight,
                videoWidth, videoHeight
            };

            return previewHeight + 15;
        },

        getParam: function(node, name) {
            const widget = node.widgets.find(w => w.name === name);
            return widget ? widget.value : null;
        },

        loadVideoFrame: function(ctx, framePath, x, y, width, height) {
            console.log("å°è¯•åŠ è½½è§†é¢‘å¸§:", framePath);

            // å¦‚æœå·²ç»åŠ è½½è¿‡è¿™ä¸ªå›¾ç‰‡ï¼Œç›´æ¥ç»˜åˆ¶
            if (this.loadedImage && this.loadedImagePath === framePath) {
                console.log("ä½¿ç”¨ç¼“å­˜çš„å›¾ç‰‡");
                ctx.drawImage(this.loadedImage, x, y, width, height);
                return;
            }

            // ç«‹å³ç»˜åˆ¶é»˜è®¤èƒŒæ™¯ï¼Œé¿å…ç©ºç™½
            const gradient = ctx.createLinearGradient(x, y, x + width, y + height);
            gradient.addColorStop(0, '#4a5568');
            gradient.addColorStop(0.5, '#2d3748');
            gradient.addColorStop(1, '#1a202c');
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, width, height);

            // åŠ è½½æ–°çš„å›¾ç‰‡
            const img = new Image();
            img.onload = () => {
                console.log("âœ… è§†é¢‘å¸§åŠ è½½æˆåŠŸ:", framePath);
                this.loadedImage = img;
                this.loadedImagePath = framePath;
                ctx.drawImage(img, x, y, width, height);
                // è§¦å‘é‡ç»˜
                if (app && app.canvas) {
                    app.canvas.setDirty(true);
                }
            };
            img.onerror = (e) => {
                console.log("âŒ æ— æ³•åŠ è½½è§†é¢‘é¢„è§ˆå¸§:", framePath, e);
                // ä¿æŒé»˜è®¤èƒŒæ™¯
            };

            // è®¾ç½®å›¾ç‰‡æº
            let imgSrc = framePath;

            console.log("å›¾ç‰‡æºURL:", imgSrc);
            img.src = imgSrc;
        },

        setParam: function(node, name, value) {
            const widget = node.widgets.find(w => w.name === name);
            if (widget) {
                widget.value = value;
                if (node.onWidgetChanged) {
                    node.onWidgetChanged(name, value);
                }
            }
        },

        detectResizeHandle: function(mouseX, mouseY, cropX, cropY, cropWidth, cropHeight) {
            const tolerance = 15; // å¢å¤§æ£€æµ‹å®¹å·®

            // æ£€æµ‹å››ä¸ªè§’ï¼ˆä¼˜å…ˆæ£€æµ‹è§’è½ï¼‰
            if (this.isNearPoint(mouseX, mouseY, cropX, cropY, tolerance)) {
                console.log("æ£€æµ‹åˆ°å·¦ä¸Šè§’");
                return 'nw';
            }
            if (this.isNearPoint(mouseX, mouseY, cropX + cropWidth, cropY, tolerance)) {
                console.log("æ£€æµ‹åˆ°å³ä¸Šè§’");
                return 'ne';
            }
            if (this.isNearPoint(mouseX, mouseY, cropX, cropY + cropHeight, tolerance)) {
                console.log("æ£€æµ‹åˆ°å·¦ä¸‹è§’");
                return 'sw';
            }
            if (this.isNearPoint(mouseX, mouseY, cropX + cropWidth, cropY + cropHeight, tolerance)) {
                console.log("æ£€æµ‹åˆ°å³ä¸‹è§’");
                return 'se';
            }

            // æ£€æµ‹å››ä¸ªè¾¹
            if (Math.abs(mouseX - cropX) < tolerance && mouseY >= cropY && mouseY <= cropY + cropHeight) {
                console.log("æ£€æµ‹åˆ°å·¦è¾¹");
                return 'w';
            }
            if (Math.abs(mouseX - (cropX + cropWidth)) < tolerance && mouseY >= cropY && mouseY <= cropY + cropHeight) {
                console.log("æ£€æµ‹åˆ°å³è¾¹");
                return 'e';
            }
            if (Math.abs(mouseY - cropY) < tolerance && mouseX >= cropX && mouseX <= cropX + cropWidth) {
                console.log("æ£€æµ‹åˆ°ä¸Šè¾¹");
                return 'n';
            }
            if (Math.abs(mouseY - (cropY + cropHeight)) < tolerance && mouseX >= cropX && mouseX <= cropX + cropWidth) {
                console.log("æ£€æµ‹åˆ°ä¸‹è¾¹");
                return 's';
            }

            // æ£€æµ‹å†…éƒ¨åŒºåŸŸï¼ˆç§»åŠ¨ï¼‰
            if (mouseX >= cropX + tolerance && mouseX <= cropX + cropWidth - tolerance &&
                mouseY >= cropY + tolerance && mouseY <= cropY + cropHeight - tolerance) {
                return 'move';
            }

            return null;
        },

        isNearPoint: function(x1, y1, x2, y2, tolerance) {
            return Math.abs(x1 - x2) < tolerance && Math.abs(y1 - y2) < tolerance;
        },

        mouse: function(event, pos, node) {
            if (!this.canvasInfo) return false;

            const { offsetX, offsetY, scale, margin, y, canvasWidth, canvasHeight, videoWidth, videoHeight } = this.canvasInfo;

            // æ£€æŸ¥æ˜¯å¦åœ¨é¢„è§ˆåŒºåŸŸå†…
            if (pos[0] < margin || pos[0] > margin + canvasWidth ||
                pos[1] < y || pos[1] > y + canvasHeight) {
                // é¼ æ ‡ç¦»å¼€åŒºåŸŸæ—¶é‡ç½®å…‰æ ‡
                if (event.type === "pointermove" && !this.isDragging) {
                    this.setCursor(null);
                }
                return false;
            }

            // è½¬æ¢åæ ‡åˆ°è§†é¢‘åæ ‡ç³»
            const videoX = (pos[0] - offsetX) / scale;
            const videoY = (pos[1] - offsetY) / scale;

            // é™åˆ¶åœ¨è§†é¢‘åŒºåŸŸå†…
            if (videoX < 0 || videoX > videoWidth || videoY < 0 || videoY > videoHeight) {
                // é¼ æ ‡ç¦»å¼€è§†é¢‘åŒºåŸŸæ—¶é‡ç½®å…‰æ ‡
                if (event.type === "pointermove" && !this.isDragging) {
                    this.setCursor(null);
                }
                return false;
            }

            // è·å–å½“å‰è£åˆ‡å‚æ•°
            const x1 = this.getParam(node, "crop_x1") || 480;
            const y1 = this.getParam(node, "crop_y1") || 270;
            const x2 = this.getParam(node, "crop_x2") || 1440;
            const y2 = this.getParam(node, "crop_y2") || 810;

            // è®¡ç®—è£åˆ‡æ¡†åœ¨ç”»å¸ƒä¸Šçš„ä½ç½®
            const cropX = x1;
            const cropY = y1;
            const cropWidth = x2 - x1;
            const cropHeight = y2 - y1;

            if (event.type === "pointermove" && !this.isDragging) {
                // æ£€æµ‹é¼ æ ‡æ‚¬åœä½ç½®ï¼Œè®¾ç½®å…‰æ ‡
                const handle = this.detectResizeHandle(videoX, videoY, cropX, cropY, cropWidth, cropHeight);
                this.setCursor(handle);
                return false;
            }

            if (event.type === "pointerdown") {
                this.isDragging = true;
                this.dragStartX = videoX;
                this.dragStartY = videoY;

                // æ£€æµ‹æ‹–æ‹½ç±»å‹
                this.resizeHandle = this.detectResizeHandle(videoX, videoY, cropX, cropY, cropWidth, cropHeight);
                console.log("æ‹–æ‹½å¼€å§‹:", this.resizeHandle, "åæ ‡:", videoX, videoY, "è£åˆ‡æ¡†:", cropX, cropY, cropWidth, cropHeight);

                // è®°å½•å½“å‰è£åˆ‡å‚æ•°
                this.startCropX1 = x1;
                this.startCropY1 = y1;
                this.startCropX2 = x2;
                this.startCropY2 = y2;

                return true;
            } else if (event.type === "pointermove" && this.isDragging) {
                const deltaX = videoX - this.dragStartX;
                const deltaY = videoY - this.dragStartY;

                let newX1 = this.startCropX1;
                let newY1 = this.startCropY1;
                let newX2 = this.startCropX2;
                let newY2 = this.startCropY2;

                // æ ¹æ®æ‹–æ‹½ç±»å‹è°ƒæ•´è£åˆ‡æ¡†
                switch (this.resizeHandle) {
                    case 'move':
                        // ç§»åŠ¨æ•´ä¸ªæ¡†
                        const currentWidth = newX2 - newX1;
                        const currentHeight = newY2 - newY1;
                        newX1 = this.startCropX1 + deltaX;
                        newY1 = this.startCropY1 + deltaY;
                        newX2 = newX1 + currentWidth;
                        newY2 = newY1 + currentHeight;
                        break;

                    case 'nw': // å·¦ä¸Šè§’
                        newX1 = this.startCropX1 + deltaX;
                        newY1 = this.startCropY1 + deltaY;
                        break;

                    case 'ne': // å³ä¸Šè§’
                        newX2 = this.startCropX2 + deltaX;
                        newY1 = this.startCropY1 + deltaY;
                        break;

                    case 'sw': // å·¦ä¸‹è§’
                        newX1 = this.startCropX1 + deltaX;
                        newY2 = this.startCropY2 + deltaY;
                        break;

                    case 'se': // å³ä¸‹è§’
                        newX2 = this.startCropX2 + deltaX;
                        newY2 = this.startCropY2 + deltaY;
                        break;

                    case 'w': // å·¦è¾¹
                        newX1 = this.startCropX1 + deltaX;
                        break;

                    case 'e': // å³è¾¹
                        newX2 = this.startCropX2 + deltaX;
                        break;

                    case 'n': // ä¸Šè¾¹
                        newY1 = this.startCropY1 + deltaY;
                        break;

                    case 's': // ä¸‹è¾¹
                        newY2 = this.startCropY2 + deltaY;
                        break;
                }

                // æ™ºèƒ½è¾¹ç•Œçº¦æŸå’Œæœ€å°å°ºå¯¸å¤„ç†
                const minSize = 50;

                // å¯¹äºç§»åŠ¨æ“ä½œï¼Œä¿æŒå°ºå¯¸ä¸å˜
                if (this.resizeHandle === 'move') {
                    const currentWidth = newX2 - newX1;
                    const currentHeight = newY2 - newY1;

                    // è¾¹ç•Œçº¦æŸ
                    newX1 = Math.max(0, Math.min(newX1, videoWidth - currentWidth));
                    newY1 = Math.max(0, Math.min(newY1, videoHeight - currentHeight));
                    newX2 = newX1 + currentWidth;
                    newY2 = newY1 + currentHeight;
                } else {
                    // å¯¹äºè°ƒæ•´å¤§å°æ“ä½œï¼Œåˆ†åˆ«å¤„ç†æ¯ä¸ªæ–¹å‘

                    // å…ˆåº”ç”¨åŸºæœ¬è¾¹ç•Œçº¦æŸ
                    newX1 = Math.max(0, Math.min(newX1, videoWidth));
                    newY1 = Math.max(0, Math.min(newY1, videoHeight));
                    newX2 = Math.max(0, Math.min(newX2, videoWidth));
                    newY2 = Math.max(0, Math.min(newY2, videoHeight));

                    // ç¡®ä¿åæ ‡é¡ºåºæ­£ç¡®
                    if (newX1 > newX2) [newX1, newX2] = [newX2, newX1];
                    if (newY1 > newY2) [newY1, newY2] = [newY2, newY1];

                    // ç¡®ä¿æœ€å°å°ºå¯¸
                    if (newX2 - newX1 < minSize) {
                        const centerX = (newX1 + newX2) / 2;
                        newX1 = Math.max(0, centerX - minSize/2);
                        newX2 = Math.min(videoWidth, newX1 + minSize);
                        if (newX2 - newX1 < minSize) {
                            newX1 = Math.max(0, newX2 - minSize);
                        }
                    }

                    if (newY2 - newY1 < minSize) {
                        const centerY = (newY1 + newY2) / 2;
                        newY1 = Math.max(0, centerY - minSize/2);
                        newY2 = Math.min(videoHeight, newY1 + minSize);
                        if (newY2 - newY1 < minSize) {
                            newY1 = Math.max(0, newY2 - minSize);
                        }
                    }
                }

                // æ›´æ–°å‚æ•°
                this.setParam(node, "crop_x1", Math.round(newX1));
                this.setParam(node, "crop_y1", Math.round(newY1));
                this.setParam(node, "crop_x2", Math.round(newX2));
                this.setParam(node, "crop_y2", Math.round(newY2));
                this.setParam(node, "crop_mode", "è‡ªå®šä¹‰åæ ‡");

                return true;
            } else if (event.type === "pointerup") {
                this.isDragging = false;
                this.resizeHandle = null;
                return true;
            }

            return false;
        },

        setCursor: function(handle) {
            if (!document.body) return;

            const cursors = {
                'nw': 'nw-resize',
                'ne': 'ne-resize',
                'sw': 'sw-resize',
                'se': 'se-resize',
                'w': 'w-resize',
                'e': 'e-resize',
                'n': 'n-resize',
                's': 's-resize',
                'move': 'move',
                null: 'default'
            };

            document.body.style.cursor = cursors[handle] || 'default';
        },

        computeSize: function(width) {
            return [width, 200];
        }
    };
}

// æ³¨å†Œæ‰©å±•
app.registerExtension({
    name: "VideoEditing.SmartCrop",

    async beforeRegisterNodeDef(nodeType, nodeData, app) {
        if (nodeData.name === "EnhancedVideoCropNode") {
            console.log("ğŸ¯ æ³¨å†Œæ™ºèƒ½è§†é¢‘è£åˆ‡èŠ‚ç‚¹æ‰©å±•");

            const onNodeCreated = nodeType.prototype.onNodeCreated;
            nodeType.prototype.onNodeCreated = function() {
                const result = onNodeCreated?.apply(this, arguments);

                console.log("ğŸ“‹ åˆ›å»ºæ™ºèƒ½è§†é¢‘è£åˆ‡èŠ‚ç‚¹ï¼Œæ·»åŠ äº¤äº’ç•Œé¢...");

                // æ·»åŠ æ¯”ä¾‹é€‰æ‹©æŒ‰é’®
                const ratioWidget = createRatioButtons(this);
                this.addCustomWidget(ratioWidget);

                // æ·»åŠ äº¤äº’å¼é¢„è§ˆ
                const previewWidget = createCropPreview(this);
                this.addCustomWidget(previewWidget);

                console.log("âœ… äº¤äº’ç•Œé¢å·²æ·»åŠ åˆ°èŠ‚ç‚¹");

                return result;
            };
        }
    }
});

console.log("ğŸ¬ æ™ºèƒ½è§†é¢‘è£åˆ‡æ‰©å±•å·²åŠ è½½");